以下是 **Python 教学路径第二章：函数与作用域** 的完整内容：

✅ 系统讲解核心知识点  
✅ 提供可运行、有注释的代码实例  
✅ 每个知识点紧扣“理解 + 实践”原则  
✅ 本章结束后附带 **5道测试题（含答案与解析）**  
✅ 为后续“内存管理”打下坚实基础（如栈帧、引用传递、作用域生命周期）

---

# 📘 第二章：函数与作用域

> ✅ **学习目标**：
> - 掌握函数定义与调用方式
> - 理解参数传递机制（位置、默认、`*args`、`**kwargs`）
> - 深入理解返回值与多返回值的实现原理
> - 掌握 Python 的 **LEGB 作用域规则**
> - 学会使用 `global` 和 `nonlocal` 控制变量作用域
> - 为后续理解“栈帧”、“闭包”、“内存生命周期”打基础

---

## 2.1 函数定义与调用

函数是组织代码的基本单元。使用 `def` 定义，`return` 返回结果。

```python
def greet(name):
    return f"Hello, {name}!"

# 调用函数
message = greet("Alice")
print(message)  # Hello, Alice!
```

📌 **关键点**：
- 函数名是**可调用对象**（本质是 `function` 类型的对象）
- 函数体内的变量默认是**局部变量**

```python
print(type(greet))  # <class 'function'>
```

---

## 2.2 参数类型详解

### ✅ 位置参数（Positional Arguments）

最基础的参数形式，顺序必须匹配。

```python
def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # 8
```

### ✅ 默认参数（Default Arguments）

参数可设默认值，提高灵活性。

```python
def power(base, exp=2):
    return base ** exp

print(power(4))        # 16（exp 使用默认值 2）
print(power(4, 3))     # 64（exp 被覆盖为 3）
```

> ⚠️ **重要警告**：不要使用可变对象作为默认参数！

```python
def bad_append(item, lst=[]):  # ❌ 危险！
    lst.append(item)
    return lst

print(bad_append(1))  # [1]
print(bad_append(2))  # [1, 2] ← 错误！共享了同一个列表
```

✅ 正确做法：
```python
def good_append(item, lst=None):
    if lst is None:
        lst = []
    lst.append(item)
    return lst

print(good_append(1))        # [1]
print(good_append(2))        # [2] ← 独立列表，安全
```

---

### ✅ 可变位置参数 `*args`

接收任意多个位置参数，打包为 **元组（tuple）**

```python
def sum_all(*args):
    print(f"args 类型: {type(args)}")  # <class 'tuple'>
    return sum(args)

print(sum_all(1, 2, 3, 4))  # 10
```

### ✅ 可变关键字参数 `**kwargs`

接收任意多个关键字参数，打包为 **字典（dict）**

```python
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Bob", age=25, city="Shanghai")
# name: Bob
# age: 25
# city: Shanghai
```

### ✅ 组合使用（经典模式）

```python
def profile(name, *hobbies, **details):
    print(f"Name: {name}")
    print(f"Hobbies: {hobbies}")
    print(f"Details: {details}")

profile("Charlie", "reading", "swimming", age=30, job="Engineer")
```

📌 输出：
```
Name: Charlie
Hobbies: ('reading', 'swimming')
Details: {'age': 30, 'job': 'Engineer'}
```

---

## 2.3 返回值与多返回值

函数可通过 `return` 返回一个或多个值。

### ✅ 单返回值
```python
def square(x):
    return x * x
```

### ✅ 多返回值（本质是返回元组）

```python
def min_max(lst):
    return min(lst), max(lst)  # 返回元组

data = [3, 1, 4, 1, 5]
result = min_max(data)
print(result)           # (1, 5)
print(type(result))     # <class 'tuple'>
```

### ✅ 解包（Unpacking）接收多返回值

```python
minimum, maximum = min_max(data)
print(f"Min: {minimum}, Max: {maximum}")  # Min: 1, Max: 5
```

> 🔍 原理：Python 的“多返回值”其实是返回一个元组，再通过解包赋值给多个变量。

---

## 2.4 作用域：LEGB 规则

Python 查找变量时遵循 **LEGB** 顺序：

| 层级 | 含义 |
|------|------|
| L | Local（局部）——函数内部 |
| E | Enclosing（嵌套）——外层函数 |
| G | Global（全局）——模块级 |
| B | Built-in（内置）——如 `print`, `len` |

### ✅ 示例：LEGB 查找过程

```python
x = "global"  # G

def outer():
    x = "enclosing"  # E
    def inner():
        x = "local"  # L
        print("inner:", x)
    inner()
    print("outer:", x)

outer()
print("global:", x)
```

📌 输出：
```
inner: local
outer: enclosing
global: global
```

---

## 2.5 `global` 与 `nonlocal` 关键字

### ✅ `global`：修改全局变量

在函数内想修改全局变量，必须用 `global` 声明。

```python
counter = 0

def increment():
    global counter
    counter += 1

increment()
print(counter)  # 1
increment()
print(counter)  # 2
```

> ❌ 若不加 `global`，Python 会创建一个同名局部变量，不会修改全局变量。

---

### ✅ `nonlocal`：修改外层嵌套函数中的变量

用于闭包中修改 `enclosing` 作用域的变量。

```python
def outer():
    x = 10
    def inner():
        nonlocal x
        x += 1
        print(f"x in inner: {x}")
    inner()
    print(f"x in outer: {x}")

outer()
```

📌 输出：
```
x in inner: 11
x in outer: 11
```

> 🔍 没有 `nonlocal`，`x += 1` 会被视为定义局部变量，导致 `UnboundLocalError`。

---

## ✅ 第二章测试题（共5题）

请独立完成以下题目，检验对“函数与作用域”的掌握程度。

---

### 🔹 题目1：函数返回值
```python
def func():
    pass

print(func())
```
输出是？

A. `None`  
B. `0`  
C. `""`  
D. 报错

---

### 🔹 题目2：默认参数陷阱
```python
def add_item(item, target=[]):
    target.append(item)
    return target

a = add_item(1)
b = add_item(2)
print(a is b)
```
输出是？

A. `True`  
B. `False`  
C. `None`  
D. 报错

---

### 🔹 题目3：作用域错误
```python
x = 5
def func():
    print(x)
    x = 10
func()
```
运行结果是？

A. 输出 `5`  
B. 输出 `10`  
C. 输出 `5` 然后 `10`  
D. 报错：`UnboundLocalError`

---

### 🔹 题目4：`*args` 类型
```python
def func(*args):
    return args

result = func(1, 2, 3)
print(type(result))
```
输出是？

A. `<class 'list'>`  
B. `<class 'tuple'>`  
C. `<class 'set'>`  
D. `<class 'dict'>`

---

### 🔹 题目5：`nonlocal` 的用途
`nonlocal` 关键字用于：

A. 访问内置函数  
B. 修改全局变量  
C. 修改外层函数中的变量  
D. 导入模块

---

## ✅ 测试题答案与解析

### ✅ 题1：A. `None`  
**解析**：函数无 `return` 语句时，默认返回 `None`。

### ✅ 题2：A. `True`  
**解析**：默认参数 `[]` 是同一个对象，`a` 和 `b` 指向同一个列表 → `a is b` 为 `True`。

### ✅ 题3：D. 报错：`UnboundLocalError`  
**解析**：函数内 `x = 10` 被视为局部变量，但 `print(x)` 在赋值前执行，引发错误。

### ✅ 题4：B. `<class 'tuple'>`  
**解析**：`*args` 收集为元组，不可变。

### ✅ 题5：C. 修改外层函数中的变量  
**解析**：`nonlocal` 用于闭包中修改 `enclosing` 作用域变量，是实现闭包状态的关键。

---

🎉 **恭喜！您已完成第二章学习与测试！**

> ✅ 所有知识点已覆盖  
> ✅ 所有代码可复制运行验证  
> ✅ 测试题全部解析清晰

