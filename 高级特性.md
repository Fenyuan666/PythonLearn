以下是 **Python 教学路径第六章：高级特性** 的完整内容：

✅ 系统讲解核心高级语法  
✅ 提供**可运行、有注释、体现设计思想的代码实例**  
✅ 每个知识点结合“原理 + 实践 + 内存/资源管理视角”  
✅ 为后续“并发与 GIL”打下坚实基础  
✅ 章末附带 **5道测试题（含答案与解析）**

---

# 📘 第六章：高级特性

> ✅ **学习目标**：
> - 掌握装饰器的定义、应用与实现原理
> - 理解上下文管理器（`with`）如何安全管理资源
> - 深入理解生成器（`yield`）与协程初步
> - 学会使用 `@contextmanager` 简化资源管理
> - 从“资源生命周期”角度理解 Python 的优雅编程范式

---

## 6.1 装饰器（Decorator）——函数增强术

装饰器是 Python 中最强大的语法之一，本质是：
> **函数嵌套 + 闭包 + 语法糖**

作用：在不修改原函数代码的前提下，**扩展其功能**（如日志、计时、权限校验）。

### ✅ 基础结构：一个返回函数的函数

```python
def my_decorator(func):
    def wrapper():
        print("调用前：准备工作")
        func()
        print("调用后：清理工作")
    return wrapper

def say_hello():
    print("Hello!")

# 手动装饰
say_hello = my_decorator(say_hello)
say_hello()
```

📌 输出：
```
调用前：准备工作
Hello!
调用后：清理工作
```

---

### ✅ 使用 `@` 语法糖

```python
@my_decorator
def say_goodbye():
    print("Goodbye!")

say_goodbye()
```

等价于：`say_goodbye = my_decorator(say_goodbye)`

---

### ✅ 带参数的装饰器

```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
```

📌 输出：
```
Hello, Alice!
Hello, Alice!
Hello, Alice!
```

> ✅ 三层函数：外层接收参数，中层接收函数，内层执行逻辑。

---

### ✅ 保留原函数元信息：使用 `@wraps`

默认情况下，装饰器会覆盖原函数的 `__name__`、`__doc__`。

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("装饰器逻辑")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """这是一个示例函数"""
    pass

print(example.__name__)  # example（若不用 wraps，则为 'wrapper'）
print(example.__doc__)   # 这是一个示例函数
```

✅ **最佳实践**：所有装饰器都应使用 `@wraps`。

---

## 6.2 上下文管理器（Context Manager）——资源安全卫士

用于确保资源（文件、锁、网络连接）在使用后**正确释放**，即使发生异常。

### ✅ 使用 `with` 语句

```python
# 安全读取文件
with open("example.txt", "w") as f:
    f.write("Hello, World!")

# 文件自动关闭，无需 f.close()
```

---

### ✅ 自定义上下文管理器：实现 `__enter__` 和 `__exit__`

```python
class ManagedResource:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print(f"获取资源: {self.name}")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print(f"释放资源: {self.name}")
        if exc_type:
            print(f"异常类型: {exc_type}, 信息: {exc_value}")
        return False  # 不抑制异常

# 使用
with ManagedResource("数据库连接") as res:
    print("正在使用资源...")
    # raise ValueError("出错了！")  # 测试异常
```

📌 输出：
```
获取资源: 数据库连接
正在使用资源...
释放资源: 数据库连接
```

> ✅ `__exit__` 在退出 `with` 块时自动调用，无论是否异常。

---

### ✅ 使用 `@contextmanager` 简化实现

来自 `contextlib`，用生成器写上下文管理器。

```python
from contextlib import contextmanager

@contextmanager
def managed_resource(name):
    print(f"获取资源: {name}")
    try:
        yield name  # 控制权交给 with 块
    finally:
        print(f"释放资源: {name}")

# 使用
with managed_resource("缓存锁") as res:
    print(f"操作 {res}")
```

📌 输出：
```
获取资源: 缓存锁
操作 缓存锁
释放资源: 缓存锁
```

> ✅ 更简洁，推荐用于简单资源管理。

---

## 6.3 生成器与协程初步

### ✅ 生成器函数：`yield` 返回迭代器

```python
def count_up_to(n):
    i = 1
    while i <= n:
        yield i
        i += 1

gen = count_up_to(3)
for x in gen:
    print(x)  # 1 2 3
```

> ✅ `yield` 使函数变成生成器，调用时返回生成器对象，**惰性计算**。

---

### ✅ 生成器状态保持

```python
def simple_gen():
    print("第一次暂停前")
    yield 1
    print("第二次暂停前")
    yield 2

g = simple_gen()
print(next(g))  # 第一次暂停前 \n 1
print(next(g))  # 第二次暂停前 \n 2
# print(next(g))  # StopIteration
```

> ✅ 局部变量在 `yield` 后保留，下次 `next()` 继续执行。

---

### ✅ 协程（Coroutine）初步：`send()` 方法

```python
def echo():
    while True:
        received = yield
        print(f"收到: {received}")

e = echo()
next(e)  # 启动生成器
e.send("Hello")  # 收到: Hello
e.send("World")  # 收到: World
```

> 🔍 这是 `asyncio` 协程的基础模型。

---

## ✅ 第六章测试题（共5题）

---

### 🔹 题目1：装饰器执行顺序
```python
def dec_a(func):
    print("A")
    return func

def dec_b(func):
    print("B")
    return func

@dec_a
@dec_b
def my_func():
    pass
```
输出是？

A. `B A`  
B. `A B`  
C. `无输出`  
D. `AB`

---

### 🔹 题目2：`@wraps` 作用
使用 `@wraps(func)` 的主要目的是？

A. 提高函数执行速度  
B. 保留原函数的 `__name__` 和 `__doc__`  
C. 自动处理异常  
D. 支持多参数

---

### 🔹 题目3：`__exit__` 返回值
如果 `__exit__` 返回 `True`，会发生什么？

A. 异常被重新抛出  
B. 异常被抑制（不抛出）  
C. 程序崩溃  
D. 无影响

---

### 🔹 题目4：生成器 `yield`
```python
def gen():
    yield 1
    return "done"

g = gen()
print(next(g))  # 输出？
```
输出是？

A. `1`  
B. `"done"`  
C. `StopIteration: done`  
D. 报错

---

### 🔹 题目5：`@contextmanager` 原理
`@contextmanager` 装饰的函数中，`yield` 之前的代码相当于？

A. `__enter__`  
B. `__exit__`  
C. `__call__`  
D. `__next__`

---

## ✅ 测试题答案与解析

### ✅ 题1：A. `B A`  
**解析**：装饰器从内到外执行：先 `@dec_b` → 打印 B，再 `@dec_a` → 打印 A。

### ✅ 题2：B. 保留原函数的 `__name__` 和 `__doc__`  
**解析**：`@wraps` 复制元数据，避免调试困难。

### ✅ 题3：B. 异常被抑制（不抛出）  
**解析**：`__exit__` 返回 `True` 表示已处理异常，不再向上抛出。

### ✅ 题4：A. `1`  
**解析**：`next(g)` 返回 `yield 1` 的值。`return` 值会作为 `StopIteration` 的 `value`，但不会在此刻输出。

### ✅ 题5：A. `__enter__`  
**解析**：`yield` 之前代码在 `with` 开始时执行（类似 `__enter__`），之后代码在 `finally` 中执行（类似 `__exit__`）。

---

🎉 **恭喜！您已完成第六章学习与测试！**

> ✅ 掌握了装饰器、上下文管理器、生成器等高级特性  
> ✅ 理解了资源管理与代码复用的设计思想  
> ✅ 为“并发编程”与“异步IO”打下坚实基础

---

📌 **下一章预告**：  
➡️ **第七章：并发与 GIL**  
- 多线程 vs 多进程
- `threading` 与 `multiprocessing` 对比
- GIL 的存在原因与影响
- 为什么多线程无法真正并行？
- I/O 密集型 vs CPU 密集型任务的选择

是否继续生成 **第七章内容**？请回复“继续”或提出您的疑问。